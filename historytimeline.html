<!DOCTYPE html>
<!-- this is historytimeline.html begun July 26, 2014 -->
<html>
<head>
  <meta charset="utf-8">
  <title>History Timeline</title>
  <style>
body {
  background-color: yellow;
  font-family: Palatino, serif;
}
#fullTContainer {
  padding: 20px 10px;
  border: 2px solid green;
}
  </style>
</head>
<body>
  <h1>History Timeline UI Example</h1>
  <div id="fullTContainer"></div>
  
  <script src="js/d3.v3.4.11.min.js"></script>
  <script>
d3.tl = {};
// added to new Timeline obj for testing;
var testErasArr = [
    {label: "Judges", start: -1100, stop: -1020,
       topY: 0, height: 1.0, bgcolor: "#A9BCF5"},
    {label: "United Kingdom", start: -1020, stop: -931,
       topY: 0, height: 1.0, bgcolor: "#F5BCA9"},
    {label: "Northern Kingdom (Israel)", start: -931, stop: -722,
       topY: 0, height: 0.7, bgcolor: "#F5A9E1"},
    {label: "Southern Kingdom (Judah)", start: -931, stop: -586,
       topY: 0.7, height: 0.3, bgcolor: "#F5A9BC"},
    {label: "Exile", start: -586, stop: -538,
       topY: 0, height: 1.0, bgcolor: "#F78181"},
    {label: "Persian Period", start: -538, stop: -332,
       topY: 0, height: 1.0, bgcolor: "#A9BCF5"},
    {label: "Hellenistic Period", start: -332, stop: -168,
       topY: 0, height: 1.0, bgcolor: "#A9E2F3"},
    {label: "Maccabean (Hasmonean) Rule", start: -168, stop: -63,
       topY: 0, height: 1.0, bgcolor: "#F5A9E1"},
    {label: "Rome: Temple", start: -63, stop: 70,
       topY: 0, height: 1.0, bgcolor: "#F5BCA9"}
];
var testPrecipEventsObj = {
    "-1100": "<p><b>1100 BCE</b> isn't a firm date: by scholarly convention, the Exodus occurred (if at all) about 1200 with Joshua's conquest of Caanan 40 years later.  So, 1100 seems to be a reasonable nominal date for the start of the period of <b>Judges</b>.</p>",
    "-1020": "<p>In <b>1020 BCE</b> (more or less) the monarchy began with the anointment by Samuel of <b>Saul</b> as King (followed by <b>David</b> and <b>Solomon</b>).</p>",
    "-931": "<p>In <b>931 BCE</b>, on the death of <b>Solomon</b>, his son and successor declined to lighten the heavy taxation imposed by his father and the ten northern tribes broke away to become the Kingdom of Israel.  The remaining two tribes (Judah and Benjamin) remained loyal to the Davidic house and formed the southern kingdom, the Kingdom of Judah.</p>",
    "-722": "<p>In <b>722 BCE</b>, Assyria conquered the Northern Kingdom and forced the people to resettle elsewhere.  Many fled to the Southern Kingdom but the others remain unaccounted for.</p>",
    "-586": "<p>In <b>586 BCE</b>, Babylonia under <b>King Nebuchadnezzar II</b> conquered the Southern Kingdom and destroyed the Temple. The elites had been sent into exile in Babylon ten years earlier (-597).</p>",
    "-538": "<p>In <b>539 BCE</b>, the Persians under <b>Cyrus</b> conquered Babylonia and in the following year Cyrus' famous edict gave permission to the Judeans to return to Jerusalem to rebuild their temple.</p>",
    "-332": "<p>In <b>334/332 BCE</b>, <b>Alexander the Great</b> conquered Judaea while passing through on his way to Persia and points east.  When he died ten years later (-323), Judaea became part of the Egyptian empire of the Ptolemies.  In <b>200 BCE</b> it came under the control of the Seleucid Empire.</p>",
    "-168": "<p>In <b>168 BCE</b>, the <b>Maccabean Revolt</b> began. It eventually established the first independent government in over 400 years.</p>",
    "-63": "<p>In <b>63 BCE</b>, the Roman Army under Pompey conquered Judea and in 37 BCE installed <b>Herod the Great</b> as client king; he was a great builder and dramatically enlarged and refurbished the Second Temple (d. 4 BCE).</p>",
    "70": "<p>In <b>70 CE</b>, the Romans ended the First Jewish War (66-70) by sacking Jerusalem and destroying the Temple.</p>"
  }

/* =============  Era constructor ====================== */
d3.tl.Era = function (label, start, stop, bgcolor) {
  this.label = label || "Example Label";
  this.start = start || -380;
  this.stop  = stop  || -220;
  this.bgcolor = bgcolor || "#F5BCA9";
  this.topY    = 0;
  this.height  = 1.0;
  this.voffset = 0;
};

/* =============  Timeline constructor ====================== */
d3.tl.Timeline = function (kind) {
  this.title = "Placeholder Title:";
  this.subtitle = "Subtitle Placeholder";
  this.eraTopMargin = 30;
  this.eraHeight = 300;
  this.timeAxisHeight = 50;
  this.svgHeight = this.eraTopMargin + this.eraHeight + this.timeAxisHeight;  // 380
  this.svgWidth = 1200;
  if (kind === "eraUI") { this.svgWidth = 500;};
  this.svgSideMargin = 25;
  this.borderColor = "red"; // Harvard Crimson;
  this.backgroundColor = "bisque";
  this.timeScale = null;
  this.erasArr = [ new d3.tl.Era() ];
  this.eraLabelsFontSize = "16px";
  this.eraLabelsFontFamily = "Palatino, Times, \"Times New Roman\", Georgia, serif";
  this.eraLabelTopMargin = 10;
  this.eraDateFontSize = "16px";

  this.containerStyles = {
    "width": (this.svgWidth + 4) + "px",
    "position": "relative",
    "font-family": "Palatino, Times, \"Times New Roman\", Georgia, serif",
    "background-color": "white"
  };
  
  this.footerHTML = "<span id=\"drawnBy\">Drawn by historytimeline.js. " +
                    "(<a href=\"https://github.com/bruml2/historytimeline\">Info " +
                    "and code</a>)</span>";
  this.footerStyles = {"padding": "10px 15px",
                       "margin-top": "20px",
                       "border": "2px solid " + this.borderColor,
                       "font-size": "12px"
  };
  // can be turned off;
  this.hasEraDatesOnHover = true;
  this.hasPrecipEventsOnHover = false;
  
  this.showingDates = false;
  this.showingAll   = false;
  // D3 selections:
  this.D3svg = null;
  this.D3erasGrp = null;
};

d3.tl.Timeline.prototype.addHeaderDiv = function (container) {
  this.containerID = container;
  // "this" is set to current selection el in .each loop below;
  var t = this;
  d3.select("#" + container)
      .style(t.containerStyles)
    .append("div")
      .attr("id", container + "-header")
      .style({"padding": "20px 30px",
              "margin-bottom": "20px",
              "border": "2px solid " + t.borderColor
             })
    .each(function() {
      // "this" is redefined as current selection el;
      d3.select(this).append("span")
        .attr("id", container + "-title")
        .style({"font-size": "24px",
                "color": t.borderColor
               })
        .html(t.title);
      d3.select(this).append("span")
        .attr("id", container + "-subtitle")
        .style({"font-size": "18px"})
        .html("&nbsp;&nbsp;" + t.subtitle);
    });
};

d3.tl.Timeline.prototype.addTimelineDiv = function (container) {
  if (this.containerID === null) {
    this.containerID = container;
  } else {
    if (this.containerID !== container) { console.log("Wrong container!"); };
  };
  // grab TimelineObj because "this" is set to current selection el below;
  var t = this;
  this.D3timeline = d3.select("#" + container)
      .style(t.containerStyles)
    .append("div")
      .attr("id", container + "-timeline")
      .attr("class", "historytimeline")
      .style({"position": "relative"})
    .each(function() {
      // inside the <div>, place an svg and a div;
      // "this" is redefined as current selection el;
      d3.select(this).append("svg")
        // .attr("class", "svg")
        .style({"width": t.svgWidth,
                "height": t.svgHeight,
                "border": "2px solid " + t.borderColor,
                "background-color": t.backgroundColor});
      d3.select(this).append("div")
        .attr("class", "precipEventsPanel");
    });
  t.D3svg = d3.select("#" + container + "-timeline svg");            
  t.D3precipEventsPanel =
            d3.select("#" + container + "-timeline .precipEventsPanel");            
  // add the styles once for all timelines on the page;
  if (document.getElementById("globalTimelineStyles") === null) {
    console.log("Adding globalTimelineStyles to body");
    d3.select("body").append("style")
      .attr("id", "globalTimelineStyles")
      .text(".timeAxisGrp path, .timeAxisGrp line {" +
            "  fill: none;" +
            "  stroke: black;" +
            "  shape-rendering: crispEdges; /* SVG attribute */}" +
            ".timeAxisGrp text {" +
            "  font-family: sans-serif;" +
            "  font-size: 13px;" +
            "  text-rendering: optimizeLegibility; /* SVG attribute */}" +
            ".historytimeline .hidden {" +
            "  display: none; }" +
            ".precipEventsPanel {" +            
            "  position: absolute;" +
            "  z-index: 2;" +
            "  border: solid 1px #aaa;" +
            "  border-radius: 8px;" +
            "  background: aliceblue;" +
            "  max-width: 400px;" +
            "  opacity: 0.000001;" +
            "  font: 15px sans-serif;" +
            "  pointer-events: none;}" +
            ".precipEventsPanel p {" +            
            "  margin: 0;" +
            "  padding: 6px}");
  } else {
    console.log("Already have globalTimelineStyles");
  };
};

d3.tl.Timeline.prototype.addFooterDiv = function (container) {
  if (this.containerID === null) {
    this.containerID = container;
  } else {
    if (this.containerID !== container) { console.log("Wrong container!"); };
  };
  d3.select("#" + container)
      .style(this.containerStyles)
    .append("div")
      .attr("id", container + "-footer")
      .style(this.footerStyles)
      .html(this.footerHTML);
};

/* ======================================================================= */
d3.tl.Timeline.prototype.drawTimeAxis = function (startYr, stopYr) {
  // set up timescale for x-axis; 
  var minDate = d3.min(this.erasArr, function(d){ return d.start });
  var maxDate = d3.max(this.erasArr, function(d){ return d.stop });
  if (startYr !== null && stopYr !== null && startYr < stopYr) {
    minDate = startYr;
    maxDate = stopYr;
  } else {
    if (startYr !== undefined) {console.log("startYr > stopYr problem")};
  }
  // console.log("min/max: " + minDate + "/" + maxDate);

  this.timeScale = d3.scale.linear()
                          .domain([minDate, maxDate])
                          .rangeRound([this.svgSideMargin,
                                  this.svgWidth - this.svgSideMargin])
                          .nice();
  // timeAxis is a function which returns the SVG elements for the axis;
  var timeAxis = d3.svg.axis()
                       .scale(this.timeScale);
  this.D3svg.append("g")
      .attr("class", "timeAxisGrp")
      // default position is at top of SVG; move to bottom;
      .attr("transform",
            "translate(0, " + (this.eraTopMargin + this.eraHeight + 15) + ")")
      // see relevant CSS styling for path, line, and text;
      .call(timeAxis);
};

/* ======================================================================= */
d3.tl.Timeline.prototype.drawEras = function (targetEraLabel) {
  // if targetEraLabel is specified, others are 50% opacity;
  // grab TimelineObj because "this" is set to current selection el below;
  var t = this;
  // D3erasGrp is a selection array of all the rects;
  this.D3erasGrp = this.D3svg.append("g")
      .attr("class", "erasGrp")
      .selectAll("rect")
      .data(this.erasArr)
      .enter()
      // one rect for each object in the array; "this" is the rect;
    .append("rect")
      // the id is the label, e.g., "UnitedKingdom" (alphanum only);
      .attr("id", function(d){ return d.label.replace(/\W/g, "") })
      .attr("class", "era")
      .attr("x", function(d){ return t.timeScale(d.start) })
      .attr("y", function(d){ return t.eraTopMargin + (d.topY * t.eraHeight) })
      // slightly rounded corners;
      .attr("rx", 4)
      .attr("ry", 4)
      .attr("width", function(d){ return t.timeScale(d.stop) -
                                         t.timeScale(d.start) })
      .attr("height", function(d){ return d.height * t.eraHeight })
      .style("fill", function(d){ return d.bgcolor })
      .style("stroke-width", 1)
      .style("stroke", "black")
      // show the two dates and the precipEventsPanel;
      .on("mouseover", function(){
        // console.log("mouseover: " + this.__data__.label);
        if (t.hasEraDatesOnHover && !t.showingAll) {
          // on mouseover of era, select the two start/stop dates whose class
          // is the era's id (the dates are text els) and make them visible;
          var classSelectorStr = ".eraDateGrp ." + d3.select(this).attr("id");
          d3.selectAll(classSelectorStr).classed("hidden", false);
        };
        if (t.hasPrecipEventsOnHover && !t.showingAll) {
          // get position and text for the precipEventsPanel; make opaque;
          var eraObj = this.__data__;
          var leftX = t.timeScale(eraObj.start) - 10;
          var topY  = t.eraTopMargin + (eraObj.topY * t.eraHeight) + 46;
          var panelText = t.precipEventsObj[eraObj.start] +
                          t.precipEventsObj[eraObj.stop];
          t.D3precipEventsPanel
              .style("position", "absolute")
              .style("left", leftX + "px")
              .style("top", topY + "px")
              .style("opacity", 1e-6)
              .html(panelText)
            .transition()
              .duration(400)
              .style("opacity", 0.95);
        }
        if (t.hasFooterText) {
          d3.select("#tlFooter")
              .html(t.footerTextObj[this.__data__.label])
              .classed("hidden", false);
        }
      }) // end of mouseover;
      // hide the two dates and the precipEventsPanel;
      .on("mouseout", function(){
        // console.log("mouseout:  " + this.__data__.label);
        if (!t.showingDates && !t.showingAll) {
          var classSelector = ".eraDateGrp ." + d3.select(this).attr("id");
          d3.selectAll(classSelector).classed("hidden", true);
        }
        if (t.hasPrecipEventsOnHover) {
          t.D3precipEventsPanel
              .transition()
              .duration(400)
              .style("opacity", 1e-6);
        }
        if (t.hasFooterText) {
          d3.select("#tlFooter")
              .classed("hidden", true);
        }
      });  // end of mouseout;
  if (targetEraLabel) {
    this.D3erasGrp.each(function(d, i) {
      if (this.__data__.label === targetEraLabel) {
        d3.select(this).style("stroke-width", 2);
      } else {
        d3.select(this).style("opacity",0.5);
      }
    });
  };
};

/* ======================================================================= */
d3.tl.Timeline.prototype.drawEraLabels = function (targetLabel) {
  var t = this;
  // create an invisible span used to measure length of longest word;
  var widthSpan = d3.select("body")
      .append("span")
      .attr("id", "overflowSpan")
      .style("position", "absolute")
      .style("visibility", "hidden");
  function getLeftAndStoreWidthVoffset (d) {
    /* this function: returns the x-coordinate of the HTML <div> which will
       contain the label (if label is wider than era then must shift div left);
       finds the longest word; gets its width; tests whether wider than the era;
       if not, returns the x-coorinate of the era-start; if so, returns the
       x-coordinate for the wider <div>; stores two values in d (the eraObj):
       the width of the <div> and 0 for voffset if property is missing;
    */
    // add a missing voffset property (pushes label down);
    d.voffset = d.voffset ? d.voffset : 0;
    // does widest word overflow? Sort by length descending;
    var words = d.label.split(/ /);
    var longestWord = 
            words.sort(function(a,b){ return b.length - a.length })[0];
    // console.log("Longest: " + longestWord);
    // put it in the invisible span and get width;
    widthSpan.text(longestWord);
    var longestWordWidth =
                      document.getElementById("overflowSpan").clientWidth;
    // console.log("Width of " + longestWord + ": " + longestWordWidth);
    var widthOfEra = t.timeScale(d.stop) - t.timeScale(d.start);
    // console.log("Width of " + d.label + ": " + widthOfEra);
    if (widthOfEra > longestWordWidth) {
      d.width = widthOfEra;
      return t.timeScale(d.start) + "px";
    } else {
      d.width = longestWordWidth + 2;
      var offsetLeft = t.timeScale(d.start) - ((d.width - t.widthOfEra) / 2);
      // console.log("Offset left: " + offsetLeft);
      return offsetLeft + "px";
    }
  } // end of getLeftAndStoreWidthVoffset();
  this.D3timeline.append("g")
      .attr("id", "eraLabelsGrp")
      .selectAll("div")
      .data(this.erasArr)
      .enter()
      // one div for each object in the array;
    .append("div")
      .attr("id", function(d){
                          return d.label.replace(/\W/g, "") + "Label" })
      .attr("class", "eraLabel")
      .style("position", "absolute")
      .style("z-index", "1")
      .style("text-align", "center")
       // if label fits, position against top-left corner of era with same
      // width; if not, position to left;
      .style("left", function(d){ return getLeftAndStoreWidthVoffset(d); })
      .style("top",  function(d){
                      return (t.eraTopMargin + (d.topY * t.eraHeight)) +
                             t.eraLabelTopMargin + d.voffset + "px" })
      .style("width", function(d){ return d.width + "px" })
      .style("font-family", function(d){
                return (d.labelFont ? d.labelFont : this.eraLabelsFontFamily) })
      .style("font-size", function(d){
                return (d.labelFontSize ? d.labelFontSize :
                                          t.eraLabelsFontSize) + "px";})
      .style("color", function(d){
                return (d.labelColor ? d.labelColor : "black");})
      .style("opacity", function(d){ if (d.label === targetLabel) {
                return 1} else { return 0.5} })
      .style("pointer-events", "none")
      .text(function(d){ return d.label });
  // finished with span!
  widthSpan.remove();
};

/* ======================================================================= */
d3.tl.Timeline.prototype.drawEraDates = function () {
  var t = this;
  // each era gets TWO hidden svg text elements; class == class-of-era;
  // mouseover an era causes the pair to appear;
  // this function is executed twice!        
  function addEraDates (startOrStop) {
    var start = startOrStop == "start" ? true : false;
    t.D3svg.append("g")
        .attr("class", start ? "eraStartDateGrp eraDateGrp" :
                               "eraStopDateGrp eraDateGrp")
        .selectAll("text")
        .data(t.erasArr)
        .enter()
      .append("text")
        .attr("class", function(d){
                                return d.label.replace(/\W/g, "") + " eraDate"})
        // ToDo: use d3 transition to show/hide;
        .classed("hidden", true)
        .attr("text-anchor", "middle")
        .attr("x", function(d){ return t.timeScale(start ? d.start : d.stop); })
        .attr("y", t.eraTopMargin - (0.5 * parseInt(t.eraDateFontSize)))
        .text(function(d){ return start ? d.start : d.stop })
        .attr("font-family", "sans-serif")
        .attr("font-size", t.eraDateFontSize)
        .attr("fill", "black")
        .attr("text-rendering", "optimizeLegibility");
  }
  addEraDates("start");
  addEraDates("stop");
  
  // This is gives the wrong value (1); why?
  console.log("Num of dates: " + d3.selectAll(".eraDate").length);   
};

/* ======================================================================= */
d3.tl.Timeline.prototype.setup = function (container) {
  // adds to DOM inside container;
  this.addHeaderDiv(container);
  this.addTimelineDiv(container);
  if (true) { this.addFooterDiv(container); };
};

/* ======================================================================= */
d3.tl.Timeline.prototype.draw = function (targetEra) {
  // draws the entire timeline assuming <container>-timeline div;
};

/* ========== END OF CODE ================================================ */
d3.tl.fullt = new d3.tl.Timeline();
// add test data to timeline;
d3.tl.fullt.erasArr = testErasArr;
d3.tl.fullt.precipEventsObj = testPrecipEventsObj;
d3.tl.fullt.hasPrecipEventsOnHover = true;
/*
d3.tl.fullt.addHeaderDiv("fullTContainer");
d3.tl.fullt.addTimelineDiv("fullTContainer");
d3.tl.fullt.addFooterDiv("fullTContainer");
*/
d3.tl.fullt.setup("fullTContainer");
d3.tl.fullt.drawTimeAxis();
d3.tl.fullt.drawEras("Persian Period");
d3.tl.fullt.drawEraLabels("Persian Period");
d3.tl.fullt.drawEraDates();

console.log(d3.tl.fullt);
  </script>
</body>
</html>
